import { PDFDocument, StandardFonts } from "pdf-lib";
import { ImageItem } from "@/types";

const A4 = { w: 595.28, h: 841.89 }; // A4 size in points

export async function imagesToA4Pdf(images: ImageItem[]) {
  const pdf = await PDFDocument.create();
  const font = await pdf.embedFont(StandardFonts.Helvetica);

  // Add two images per page
  for (let i = 0; i < images.length; i += 2) {
    const page = pdf.addPage([A4.w, A4.h]);
    const slotH = (A4.h - 60) / 2; // margin top+bottom = 60
    const slots = [
      { x: 30, y: A4.h - 30 - slotH, w: A4.w - 60, h: slotH },
      { x: 30, y: 30,               w: A4.w - 60, h: slotH },
    ];

    for (let s = 0; s < 2; s++) {
      const img = images[i + s];
      if (!img) break;

      const bytes = dataUrlToBytes(img.dataUrl);
      const embedded = img.dataUrl.startsWith("data:image/png")
        ? await pdf.embedPng(bytes)
        : await pdf.embedJpg(bytes);

      const { width, height } = embedded.scale(1);
      const box = slots[s];
      const scale = Math.min(box.w / width, box.h / height);
      const drawW = width * scale;
      const drawH = height * scale;
      const dx = box.x + (box.w - drawW) / 2;
      const dy = box.y + (box.h - drawH) / 2;

      page.drawImage(embedded, { x: dx, y: dy, width: drawW, height: drawH });
    }

    page.drawText("Generated by Test Generator", {
      x: 30,
      y: 15,
      size: 8,
      font,
    });
  }

  const bytes = await pdf.save();

  // Convert pdf-lib bytes to a valid ArrayBuffer
  const arrayBuffer = bytes.buffer.slice(
    bytes.byteOffset,
    bytes.byteOffset + bytes.byteLength
  );
  
  // Create the PDF blob safely for TypeScript
  return new Blob([arrayBuffer as ArrayBuffer], { type: "application/pdf" });
}

// helper to decode dataURL to bytes
function dataUrlToBytes(dataUrl: string) {
  const base64 = dataUrl.split(",")[1];
  return Uint8Array.from(atob(base64), c => c.charCodeAt(0));
}
